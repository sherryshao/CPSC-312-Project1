-- 2013W1 CPSC 312 101
-- Project #1
-- Eric Chu (73265092) & Sherry Shao (60135084)

oska_k3s7 :: [String] -> Char -> Int -> [String]
oska_k3s7 board player depth = generateNewBoard board player depth

-- generateNewBoard : Set up initial state of paths and min max state
--		Star

generateNewBoard :: [String] -> Char -> Int -> [String]
generateNewBoard board player depth 
	| depth == 0			= board
	| otherwise				= fst (generateNewBoardWithDepth player depth True (board, 0))

-- generateNewBoardWithDepth : i.e. the minimax function
-- 		Pass board up if it does not have new boards to generate.
--		At each level, get the best/worst board dependent on isMax.
--		When depth is reached pass up heuristics.

generateNewBoardWithDepth :: Char -> Int -> Bool -> ([String], Int) -> ([String], Int)
generateNewBoardWithDepth player depth isMax board
	| null newBoards	= board
	| depth == 1 		= generateEvaluatedBoard newBoards isMax
	| otherwise			= generateEvaluatedBoard (zip (map fst newBoards) (map snd newTuples)) isMax
	where
		newPlayer = if (player == 'w') then 'b' else 'w'
		newBoards = generateNewStates (fst board) player isMax
		newTuples = map (generateNewBoardWithDepth newPlayer (depth-1) (not isMax)) newBoards

-- Evaluation Functions

-- generateEvaluatedBoard : Determines if we're looking for best or worst board

generateEvaluatedBoard :: [([String], Int)] -> Bool -> ([String], Int)
generateEvaluatedBoard boards isMax
	| isMax  	= generateBestBoard boards (head boards)
	| otherwise	= generateWorstBoard boards (head boards)

-- generateBestBoard : Returns best board give a set of boards (max)

generateBestBoard :: [([String], Int)] -> ([String], Int) -> ([String], Int)
generateBestBoard boards bestBoard
	| null boards				= bestBoard
	| (snd currBoard) > (snd bestBoard)	= 
		generateBestBoard (tail boards) currBoard
	| otherwise					=
		generateBestBoard (tail boards) bestBoard
	where
		currBoard = head boards

-- generateWorstBoard : Returns worst board give a set of boards (min)

generateWorstBoard :: [([String], Int)] -> ([String], Int) -> ([String], Int)
generateWorstBoard boards worstBoard
	| null boards				= worstBoard
	| (snd currBoard) < (snd worstBoard)	= 
		generateWorstBoard (tail boards) currBoard
	| otherwise					=
		generateWorstBoard (tail boards) worstBoard
	where
		currBoard = head boards

-- New State Generation Fuctions

-- main function used to generate all new states one step away from the given state along with a score assesed for each individual state generated
-- currBoard: currentState;
-- player: scores assessed in terms of how favourable it is for the indicated player color (w or b), this indicates the colour the program is playing for;
-- isMax: indicates whether the level to be evaluated is min or max, if isMax == True, then it is the program's turn to make a move and new states would be generated as such
--     ...otherwise new states will be generated by moving one of the opponents pawns
generateNewStates :: [String] -> Char -> Bool -> [([String], Int)]
generateNewStates currBoard player isMax
	| ((player == 'w') && isMax) || ((player == 'b') && not isMax)		
						= assignScores (generateNewStatesNoScore currBoard 'w' (getAllPawns currBoard 'w')) player (fromIntegral (length (getAllPawns currBoard player)))
	| ((player == 'b') && isMax) || ((player == 'w') && not isMax)		
						= assignScores (generateNewStatesNoScore (reverse currBoard) 'b' (getAllPawns (reverse currBoard) 'b')) player (fromIntegral (length (getAllPawns (reverse currBoard) player)))
	| otherwise			= []

-- main function that assigns scores to each state given a list of states; by calling assignScore for each state
-- player: score assesed in terms of how favourable it is for the indicated player
-- numOfPawns: total number of pawns for the indicated player color that are still remaining on baord
assignScores :: [[String]] -> Char -> Float -> [([String], Int)]
assignScores newStates player numOfPawns
	| null newStates 	= []
	| otherwise 		= assignScore (head newStates) player numOfPawns : assignScores (tail newStates) player numOfPawns

-- assign score to a the given state
-- params descriptions are same as assignScores
-- if given player == 'w', then score is calculated by the subtracting the score calculated for 'b' from the score calculated for 'w'
-- ; opposite is true if player == 'b'
-- details of how score is caluclated for each player is implemented in assignScore' and assignScoreRow
-- first checks if there is a winner already, if winner is the opponent, assign an extremely large negative value, if winner is the program, then assign an extremely large positive value
-- ; if there is no winner, then proceed to calculating scores as usual
assignScore :: [String] -> Char -> Float -> ([String], Int)
assignScore state player numOfPawns
	| (getWinner state) /= '-'
						= if (getWinner state) == 't' then (state, 0)
							else if (getWinner state) == player
								then (state, (100000 * (length state)))
								else (state, (-100000 * (length state)))
	| player == 'w'		= (state, ((assignScore' state 'w' 0 numOfPawns (fromIntegral (length (state !! 0)))) - (assignScore' (reverse state) 'b' 0 numOfPawnsOppo (fromIntegral (length (state !! 0))))))
	| otherwise			= (state, ((assignScore' (reverse state) 'b' 0 numOfPawns (fromIntegral (length (state !! 0)))) - (assignScore' state 'w' 0 numOfPawnsOppo (fromIntegral (length (state !! 0))))))
	where numOfPawnsOppo = fromIntegral (length (getAllPawns state (getOpponent player)))

-- helper to assignScore to assign score to given state
-- state: given state to calculate score for
-- player: given player colour to calculate score for
-- level: indicates which row is of the state is currently being processed, this contributes to the score as the further a pawn has gone, the higher the score would be assigned
--        ; because level is an indication of how likely the player is to win
-- numOfPawns: the number of pawns player has that are still on board
-- totalPawns: the number of pawns player has at the start of the game
-- numOfPawns and totalPawns enable the program to figure out how many pawns have been killed by the opponent and therefore take this into account for the score calculation
assignScore' :: [String] -> Char -> Int -> Float -> Float -> Int
assignScore' state player level numOfPawns totalPawns
	| null state 	= 0
	| otherwise		= (assignScoreRow (head state) player level numOfPawns totalPawns) + (assignScore' (tail state) player (level + 1) numOfPawns totalPawns)

-- contains score calculation details (heuristics)
-- each pawn gains 10 points each time it advances in the game
-- for the pawns that have been removed from the board, 80% of their potential score is transferred to the remainig pawns and the potential score for the remaining pawns increases
-- this means that sacrificing a pawn that is still close to the starting point would increase the score if other pawns have already advanced well into the oppose end of the board
-- the lost of 20% of potential score indicates that lost of pawns are unfavourable as if all pawns are lost then the player will also have lost the game
assignScoreRow :: String -> Char -> Int -> Float -> Float -> Int
assignScoreRow row player level numOfPawns totalPawns
	| null row 					= 0
	| (head row) ==  player 	= ((10 * fromIntegral level)) + (ceiling ( ( ((0.8 * 10 * totalPawns * (totalPawns - numOfPawns)) / numOfPawns) / ((2 * totalPawns) - 4) ) * fromIntegral level ) )
									+ (assignScoreRow (tail row) player level numOfPawns totalPawns)
	| otherwise					= assignScoreRow (tail row) player level numOfPawns totalPawns

-- generate new states as a list of states
generateNewStatesNoScore :: [String] -> Char -> [(Int, Int)] -> [[String]]
generateNewStatesNoScore currBoard player pawnlocs
	| player == 'w'		= generateNewStates' currBoard player pawnlocs
	| player == 'b'		= reverseNewStates (generateNewStates' currBoard player pawnlocs)
	| otherwise			= []

-- helper funciton used to reverse state representaiton for conveniente use for both colors - 'w' and 'b'
reverseNewStates :: [[String]] -> [[String]] 
reverseNewStates states
	| null states 	= []
	| otherwise 	= reverse (head states): reverseNewStates (tail states)

-- called by generateNewStatesNoScore to help generate new states
generateNewStates' :: [String] -> Char -> [(Int, Int)] -> [[String]]
generateNewStates' currBoard player pawnlocs
	| null pawnlocs		= []
	| otherwise			= generateNewStatesPawn currBoard player (head pawnlocs) ++ generateNewStates' currBoard player (tail pawnlocs)

-- generate new states for given pawn with indicated pawn location
-- pawn location is defined by row and col number in the pawnloc tuple
generateNewStatesPawn :: [String] -> Char -> (Int, Int) -> [[String]]
generateNewStatesPawn currBoard player pawnloc 	
	= filter (\x -> not (null x)) ((generateNewStatePawnMvLeft currBoard player pawnloc) : (generateNewStatePawnMvRight currBoard player pawnloc) : 
											(generateNewStatePawnJumpLeft currBoard player pawnloc) : (generateNewStatePawnJumpRight currBoard player pawnloc) : [])

-- moves a given pawn left and forward relative to direction of travel
-- this is the only pawn moving function that contains real implementaiton, other pawn moving functions makes use of this default function with representation adjusted appropriately
generateNewStatePawnMvLeftDefault :: [String] -> Char -> (Int, Int) -> Bool -> [String]
generateNewStatePawnMvLeftDefault currBoard player pawnloc isJump
	| ((fst pawnloc) >= (length currBoard) - 1) || null (fst newStr2)		= []
	| not isJump	= replaceListElem (replaceListElem currBoard (fst pawnloc) (generateStr1 (currBoard !! (fst pawnloc)) (snd pawnloc))) (fst pawnloc + 1) (fst newStr2)
	| otherwise 	= generateNewStatePawnMvLeftDefault (replaceListElem (replaceListElem currBoard (fst pawnloc) (generateStr1 (currBoard !! (fst pawnloc)) (snd pawnloc))) (fst pawnloc + 1) (fst newStr2))
						player ((fst pawnloc + 1), snd newStr2) False
	where newStr2 = generateStr2MvLeft (currBoard !! (fst pawnloc)) (currBoard !! (fst pawnloc + 1)) (snd pawnloc) isJump

-- moves given pawn left and forward simply by passing params into generateNewStatePawnMvLeftDefault
-- this funciton exists for consistency in funciton naming and organization
generateNewStatePawnMvLeft :: [String] -> Char -> (Int, Int) -> [String]
generateNewStatePawnMvLeft currBoard player pawnloc	
	= generateNewStatePawnMvLeftDefault currBoard player pawnloc False

-- moves given pawn right and forward
generateNewStatePawnMvRight :: [String] -> Char -> (Int, Int) -> [String]
generateNewStatePawnMvRight currBoard player pawnloc	
	= reverseBoard (generateNewStatePawnMvLeftDefault (reverseBoard currBoard) player (fst pawnloc, (length (currBoard !! (fst pawnloc)) - (snd pawnloc + 1))) False)

-- jumps given pawn left and forward where appropriate (removing an opponene pawn)
generateNewStatePawnJumpLeft :: [String] -> Char -> (Int, Int) -> [String]
generateNewStatePawnJumpLeft currBoard player pawnloc
	= generateNewStatePawnMvLeftDefault currBoard player pawnloc True

-- jumps given pawn right and forward where appropriate (removing an opponene pawn)
generateNewStatePawnJumpRight :: [String] -> Char -> (Int, Int) -> [String]
generateNewStatePawnJumpRight currBoard player pawnloc
	= reverseBoard (generateNewStatePawnMvLeftDefault (reverseBoard currBoard) player (fst pawnloc, (length (currBoard !! (fst pawnloc)) - (snd pawnloc + 1))) True)

-- generates resulting str1 from generating new state
-- used to replace str1 in current state
generateStr1 :: String -> Int -> String
generateStr1 str1 index	= replaceListElem str1 index '-'

-- generates resulting str2 from generating new state when moving pawn left and forward
-- used to replace str2 in current state
generateStr2MvLeft :: String -> String -> Int -> Bool -> (String, Int)
generateStr2MvLeft str1 str2 index isJump
	| ((length str1 - length str2) == 1) && (index > 0)					= makeMove str2 (index - 1) (str1 !! index) isJump
	| ((length str1 - length str2) == -1) && (index < length str1)		= makeMove str2 index (str1 !! index) isJump
	| otherwise															= ([], 0)

-- called by generateStr1MvLeft to actually move pawns
makeMove :: String -> Int -> Char -> Bool -> (String, Int)
makeMove str2 index pawn isJump
	| (isJump && canJump pawn (str2 !! index)) || (not isJump && canMove pawn (str2 !! index))	
					= ((replaceListElem str2 index pawn), index)
	| otherwise						= ([], 0)


-- helper functions

-- checks if a pawn can be moved from location1 to location2 	
canMove :: Char -> Char -> Bool
canMove pawn1 pawn2		= (not (isEmpty pawn1)) && isEmpty pawn2

-- checks if a pawn can jump over another board location to remove an opponent pawn
canJump :: Char -> Char -> Bool
canJump pawn1 pawn2
	| (pawn1 == 'w') && (pawn2 == 'b')	= True
	| (pawn1 == 'b') && (pawn2 == 'w') 	= True
	| otherwise							= False

-- checks if a location on board is empty
isEmpty :: Char -> Bool
isEmpty block =		block == '-'
	
-- utility funciton used to replce elements in strings / board representations
replaceListElem :: [a] -> Int -> a -> [a]
replaceListElem list index elem
	| null list		= []
	| index == 0	= elem : (tail list)
	| otherwise		= (head list) : replaceListElem (tail list) (index - 1) elem		

-- get all pawn locations given state and player colour
getAllPawns :: [String] -> Char -> [(Int, Int)]
getAllPawns board player	= getAllPawns' board player 0

getAllPawns' :: [String] -> Char -> Int -> [(Int, Int)]
getAllPawns' board player rowNum
	| null board 	= []
	| otherwise 	= getAllPawnsRow (head board) player rowNum ++ getAllPawns' (tail board) player (rowNum + 1)
	
getAllPawnsRow :: String -> Char -> Int -> [(Int, Int)]
getAllPawnsRow row player rowNum	= getAllPawnsRow' row player rowNum 0

getAllPawnsRow' :: String -> Char -> Int -> Int -> [(Int, Int)]
getAllPawnsRow' row player rowNum colNum
	| null row 				= []
	| (head row) == player	= (rowNum, colNum) : getAllPawnsRow' (tail row) player rowNum (colNum + 1)
	| otherwise				= getAllPawnsRow' (tail row) player rowNum (colNum + 1)

reverseBoard :: [String] -> [String]
reverseBoard board = map reverse board

getOpponent :: Char -> Char
getOpponent player
	| player == 'w' 	= 'b'
	| otherwise			= 'w'

-- identifies the winner if there is one in the given state, otherwise return '-'
-- used for assigning extremely large score to the winning player in calculating scores
getWinner :: [String] -> Char
getWinner state
	| (not (midHasBlack state)) && (lastHasBlack state) && (not (midHasWhite state)) && (lastHasWhite state)
					= if (blackGoals - whiteGoals) > 0 then 'b' 
						else if (blackGoals - whiteGoals) < 0 then 'w'
							else 't'
	| (not (midHasBlack state)) && (lastHasBlack state) 		= 'b'
	| (not (midHasBlack state)) && (not (lastHasBlack state)) 	= 'w'
	| (not (midHasWhite state)) && (lastHasWhite state) 		= 'w'
	| (not (midHasWhite state)) && (not (lastHasWhite state)) 	= 'b'
	| otherwise													= '-'
	where 
		blackGoals = length (getAllPawnsRow (state !! 0) 'b' 0)
		whiteGoals = length (getAllPawnsRow (state !! (length state - 1)) 'w' (length state - 1))

-- helper functions for getWinner

midHasBlack :: [String] -> Bool
midHasBlack state 	= hasBlack (tail state)

lastHasBlack :: [String] -> Bool
lastHasBlack state 	= hasBlack [(head state)]

hasBlack :: [String] -> Bool
hasBlack strs
	| null strs 			= False
	| elem 'b' (head strs)	= True
	| otherwise 			= hasBlack (tail strs)

midHasWhite :: [String] -> Bool
midHasWhite state 	= hasWhite (init state)

lastHasWhite :: [String] -> Bool
lastHasWhite state 	= hasWhite [(last state)]

hasWhite :: [String] -> Bool
hasWhite strs
	| null strs 			= False
	| elem 'w' (head strs)	= True
	| otherwise 			= hasWhite (tail strs)




